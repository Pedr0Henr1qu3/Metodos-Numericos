# -*- coding: utf-8 -*-
"""atividade_avaliativa_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OZPlSndT47MTRm38xkzQdh4IOQ-ts0LE

# Matemática Computacional II

## Atividade avaliativa #3

### MTM00042 - 1ºSem/2024- Prof. Tiago M. Buriol

**Nome:**
"""

import numpy as np
import matplotlib.pyplot as plt

"""**1.** Faça o gráfico da função

$$\quad f(x, y)=\left(x^2+3 y^2\right) e^{-x^2-y^2}$$

Em seguida represente a função com curvas de nível.


"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Definindo a função
def f(x, y):
    return (x**2 + 3*y**2) * np.exp(-(x**2 + y**2))

# Criando os dados para o gráfico
x = np.linspace(-2, 2, 100)
y = np.linspace(-2, 2, 100)
X, Y = np.meshgrid(x, y)
Z = f(X, Y)

# Plotando o gráfico 3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(x,y)')
ax.set_title('Gráfico da função f(x,y)')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define a função d
def d(x, y):
    return (2*x + 3*y**2) * np.exp(-x**2 - y**2)

# Define os intervalos de x e y
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)

# Cria a malha de pontos xi, yi
xi, yi = np.meshgrid(x, y)

# Calcula os valores de d(xi, yi)
zi = d(xi, yi)

# Cria o gráfico de contorno
plt.figure(figsize=(8, 6))
contour = plt.contour(xi, yi, zi, levels=20, cmap='viridis')
plt.colorbar(contour, label='Valor de d(x, y)')
plt.title('Curvas de Nível de d(x, y)')
plt.xlabel('x')
plt.ylabel('y')
plt.grid(True)
plt.show()

"""**2.** Plote os campos vetoriais:

(a) $\mathbf{F}(x, y)=\left\langle\ln \left(1+y^2\right), \ln \left(1+x^2\right)\right\rangle$

(b) $\mathbf{F}(x, y, z)=\frac{y}{z} \mathbf{i}-\frac{x}{z} \mathbf{j}+\frac{z}{4} \mathbf{k}$
"""

import numpy as np
import matplotlib.pyplot as plt

# Definindo a função do campo vetorial F(x,y)
def F1(x, y):
    return np.log(1 + y**2), np.log(1 + x**2)

# Criando uma grade de pontos para o vetor
x = np.linspace(-2, 2, 20)
y = np.linspace(-2, 2, 20)
X, Y = np.meshgrid(x, y)

# Calculando o campo vetorial em cada ponto da grade
U, V = F1(X, Y)

# Plotando o campo vetorial
plt.figure(figsize=(8, 6))
plt.quiver(X, Y, U, V, scale=20, color='b')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Campo Vetorial F(x,y) = (ln(1+y^2), ln(1+x^2))')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Definindo a função do campo vetorial F(x,y,z)
def F2(x, y, z):
    return y/z, -x/z, z/4

# Criando uma grade de pontos para o vetor
x = np.linspace(-2, 2, 20)
y = np.linspace(-2, 2, 20)
z = np.linspace(-2, 2, 20)
X, Y, Z = np.meshgrid(x, y, z)

# Calculando o campo vetorial em cada ponto da grade
U, V, W = F2(X, Y, Z)

# Plotando o campo vetorial
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.quiver(X, Y, Z, U, V, W, length=0.1, normalize=True, color='b')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Campo Vetorial F(x,y,z) = (y/z)*i - (x/z)*j + (z/4)*k')
plt.show()

"""**3.** Represente graficamente a função
$$
f(x, y)=y^2-2 y \cos x, \quad-5 \leq x \leq 5, \quad -2 \leq y \leq 2,
$$

Então, determine os valores máximos e mínimos locais e pontos de sela.

"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Definindo a função f(x,y)
def f(x, y):
    return y**2 - 2*y*np.cos(x)

# Criando uma grade de pontos para o gráfico
x = np.linspace(-5, 5, 100)
y = np.linspace(-2, 2, 100)
X, Y = np.meshgrid(x, y)
Z = f(X, Y)

# Plotando o gráfico 3D da função
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(x,y)')
ax.set_title('Gráfico da função f(x,y) = y^2 - 2y*cos(x)')
plt.show()

from sympy import symbols, cos, sin, diff, hessian, solve

# Definindo as variáveis simbólicas
x, y = symbols('x y')

# Definindo a função f(x, y)
f = y**2 - 2*y*cos(x)

# Calculando as derivadas parciais de f(x, y)
df_dx = diff(f, x)
df_dy = diff(f, y)

# Encontrando os pontos críticos
critical_points = solve([df_dx, df_dy], (x, y))
print("Pontos críticos:")
print(critical_points)

# Calculando a matriz hessiana de f(x, y)
H = hessian(f, (x, y))
print("\nMatriz hessiana:")
print(H)

# Função para classificar os pontos críticos
def classify_critical_points(critical_points, H):
    classifications = []
    for point in critical_points:
        x_val, y_val = point
        hessian_at_point = H.subs({x: x_val, y: y_val})
        eigenvalues = hessian_at_point.eigenvals()
        if all(val > 0 for val in eigenvalues):
            classification = 'Mínimo local'
        elif all(val < 0 for val in eigenvalues):
            classification = 'Máximo local'
        else:
            classification = 'Ponto de sela'
        classifications.append((point, classification))
    return classifications

# Classificando os pontos críticos
classifications = classify_critical_points(critical_points, H)

# Exibindo os resultados
print("\nClassificação dos pontos críticos:")
for point, classification in classifications:
    print(f"Ponto: {point}, Classificação: {classification}")

"""**4.** Determine o volume do sólido abaixo da superficie
$$z=1+x^2 y^2$$
e acima da região limitada por $x=y^2$ e $x=4$. Faça o gráfico de $z$  e da região de integração
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Função da superfície z = 1 + x^2*y^2
def surface_func(x, y):
    return 1 + x**2 * y**2

# Limites da região de integração
x = np.linspace(0, 4, 100)
y = np.linspace(-2, 2, 100)
X, Y = np.meshgrid(x, y)

# Plot da superfície z
Z = surface_func(X, Y)

fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(121, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Superfície z = 1 + x^2*y^2')

# Plot da região de integração no plano xy
ax = fig.add_subplot(122)
ax.fill_between(x, x**0.5, 4, color='lightblue', alpha=0.6)
ax.set_xlim(0, 4)
ax.set_ylim(-2, 2)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_title('Região de integração: x = y^2 a x = 4')

plt.tight_layout()
plt.show()

import scipy.integrate as integrate

# Definindo a função da superfície z = 1 + x^2*y^2
def surface_func(x, y):
    return 1 + x**2 * y**2

# Definindo os limites de integração
def integrand(y, x):
    return surface_func(x, y)

# Limites de integração para x e y
x_min, x_max = 0, 4
y_min = lambda x: 0
y_max = lambda x: np.sqrt(x)

# Realizando a integração dupla
volume, error = integrate.dblquad(integrand, x_min, x_max, y_min, y_max)

print(f"Volume do sólido: {volume:.4f} unidades cúbicas")

"""**5.** Faça o gráfico e encontre uma aproximação para o comprimento da curva $C$ com equações paramétricas

$$x=e^{-t} \cos 4 t$$
$$y=e^{-t} \operatorname{sen} 4 t$$
$$z=e^{-t}$$

com $0 \leq t \leq 2 \pi$.

Em seguida, encontre o valor exato da integral $\int_C x^3 y^2 z d s$, .
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Definindo as funções paramétricas
def x_parametric(t):
    return np.exp(-t) * np.cos(4*t)

def y_parametric(t):
    return np.exp(-t) * np.sin(4*t)

def z_parametric(t):
    return np.exp(-t)

# Parâmetro t
t = np.linspace(0, 2*np.pi, 100)

# Calculando as coordenadas da curva C
x = x_parametric(t)
y = y_parametric(t)
z = z_parametric(t)

# Plotando o gráfico 3D da curva C
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.plot(x, y, z, label='Curva C', color='b')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Gráfico da curva C com equações paramétricas')
ax.legend()
plt.show()

# Função para calcular o comprimento da curva C
def length_of_curve(x_func, y_func, z_func, t_values):
    dt = t_values[1] - t_values[0]
    length = 0
    for i in range(len(t_values) - 1):
        dx_dt = (x_func(t_values[i+1]) - x_func(t_values[i])) / dt
        dy_dt = (y_func(t_values[i+1]) - y_func(t_values[i])) / dt
        dz_dt = (z_func(t_values[i+1]) - z_func(t_values[i])) / dt
        length += np.sqrt(dx_dt**2 + dy_dt**2 + dz_dt**2) * dt
    return length

# Calculando o comprimento da curva C
curve_length = length_of_curve(x_parametric, y_parametric, z_parametric, t)

print(f"Aproximação para o comprimento da curva C: {curve_length:.4f}")

# Função integranda para x^3 * y^2 * z
def integrand(t):
    return (x_parametric(t)**3) * (y_parametric(t)**2) * z_parametric(t)

# Integração numérica para encontrar o valor exato da integral
exact_integral, _ = integrate.quad(integrand, 0, 2*np.pi)

print(f"Valor exato da integral ∫(C) x^3 * y^2 * z ds: {exact_integral:.4f}")